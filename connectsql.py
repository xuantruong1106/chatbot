# K·∫øt n·ªëi ƒë·∫øn PostgreSQL
import streamlit as st
import pandas as pd
import psycopg2
from werkzeug.security import generate_password_hash, check_password_hash
import plotly.express as px


def connect_to_postgresql():
    conn = psycopg2.connect(
        dbname="chatbot",
        user="postgres",
        password="andubadao123",
        host="localhost",
        port="5432"
    )
    return conn


conn = connect_to_postgresql()
cursor = conn.cursor()


def load_from_postgresql():
    cursor.execute("SELECT question FROM faq")
    rows = cursor.fetchall()
    questions = [row[0] for row in rows]
    return questions


def mactching_with_load_from_postgresql(ques):
    questions = load_from_postgresql()
    for i in questions:
        if (i == ques):
            return True
            break
    return False


def get_answer(question):
    cursor.execute("select get_faq_answer(%s)", (question,))
    answer = cursor.fetchone()
    if answer:
        return answer[0], True
    else:
        return 'r·∫•t c·∫£m ∆°n c√¢u h·ªèi, nh√† tr∆∞·ªùng s·∫Ω gi·∫£i ƒë√°p c√¢u h·ªèi c·ªßa b·∫°n sau', False

# Th√™m c√¢u h·ªèi v√† c√¢u tr·∫£ l·ªùi v√†o PostgreSQL


def add_to_postgresql(question, answer):
    cursor.execute("call insert_faq_procedure(%s, %s)", (question, answer))
    conn.commit()
    cursor.close()
    conn.close()


def get_answer_id_faq(question):
    cursor.execute("select get_id_faq(%s)", (question,))
    answer = cursor.fetchone()
    if answer:
        return answer[0]
    else:
        return 'r·∫•t c·∫£m ∆°n c√¢u h·ªèi, nh√† tr∆∞·ªùng s·∫Ω gi·∫£i ƒë√°p c√¢u h·ªèi c·ªßa b·∫°n sau'


def get_answer_id_faq_from_key_word(question):
    cursor.execute("select get_answer_id_faq_from_key_word(%s)", (question,))
    answer = cursor.fetchone()
    print(answer)
    if answer:
        print(answer[0])
        return answer[0], True
    else:
        return 'r·∫•t c·∫£m ∆°n c√¢u h·ªèi, nh√† tr∆∞·ªùng s·∫Ω gi·∫£i ƒë√°p c√¢u h·ªèi c·ªßa b·∫°n sau', False

# -----------------------------------nhan------------------------------------------------


def check_user(username, password):
    conn = connect_to_postgresql()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT password, role FROM users WHERE username = %s", (username,))
    user = cursor.fetchone()
    cursor.close()
    conn.close()
    if user and check_password_hash(user[0], password):
        return user[1]
    return None


def create_user(username, password):
    conn = connect_to_postgresql()
    cursor = conn.cursor()
    hashed_password = generate_password_hash(password)
    try:
        cursor.execute(
            "INSERT INTO users (username, password, role) VALUES (%s, %s, 'user')", (username, hashed_password))
        conn.commit()
    except psycopg2.errors.UniqueViolation:
        conn.rollback()
        return False
    finally:
        cursor.close()
        conn.close()
    return True

def log_user_question(question):
    try:
        conn = connect_to_postgresql()
        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT INTO user_questions (question, timestamp)
            VALUES (%s, NOW())
            """,
            (question,)
        )
        conn.commit()
        print("C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c l∆∞u.")
    except Exception as e:
        print(f"L·ªói khi l∆∞u c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng: {e}")
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

def load_faq():
    conn = connect_to_postgresql()
    cursor = conn.cursor()
    cursor.execute("SELECT question, answer FROM faq")
    rows = cursor.fetchall()
    cursor.close()
    conn.close()
    questions = [row[0] for row in rows]
    answers = {row[0]: row[1] for row in rows}
    return questions, answers


def is_question_duplicate(question):
    try:
        conn = connect_to_postgresql()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT COUNT(*) FROM faq WHERE question = %s", (question,))
        count = cursor.fetchone()[0]

        cursor.close()
        conn.close()

        return count > 0  # N·∫øu c√≥ √≠t nh·∫•t m·ªôt b·∫£n ghi tr√πng l·∫∑p, tr·∫£ v·ªÅ True
    except Exception as e:
        print(f"L·ªói khi ki·ªÉm tra c√¢u h·ªèi: {e}")
        return False


def add_faq(question, answer):
    if is_question_duplicate(question):
        print("C√¢u h·ªèi ƒë√£ t·ªìn t·∫°i!")
    else:
        try:
            conn = connect_to_postgresql()
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO faq (question, answer) VALUES (%s, %s)",
                (question, answer)
            )

            conn.commit()
            cursor.close()
            conn.close()

            print("D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c th√™m th√†nh c√¥ng!")
            return True
        except Exception as e:
            print(f"L·ªói khi th√™m c√¢u h·ªèi: {e}")
            return False


def update_faq(old_question, new_question, new_answer):
    conn = connect_to_postgresql()
    cursor = conn.cursor()
    cursor.execute("UPDATE faq SET question = %s, answer = %s WHERE question = %s",
                   (new_question, new_answer, old_question))
    conn.commit()
    cursor.close()
    conn.close()


def delete_faq(question):
    conn = connect_to_postgresql()
    cursor = conn.cursor()
    cursor.execute("DELETE FROM faq WHERE question = %s", (question,))
    conn.commit()
    cursor.close()
    conn.close()

# Ghi log v√†o c∆° s·ªü d·ªØ li·ªáu


def load_unanswered_logs():
    conn = connect_to_postgresql()
    cursor = conn.cursor()
    query = """
        SELECT id, question
        FROM logs
        WHERE answer = 'R·∫•t c·∫£m ∆°n c√¢u h·ªèi, nh√† tr∆∞·ªùng s·∫Ω gi·∫£i ƒë√°p sau.'
        ORDER BY timestamp DESC
    """
    cursor.execute(query)
    logs = cursor.fetchall()
    cursor.close()
    conn.close()
    return logs


def log_chat(username, question, answer, is_answered):
    try:
        conn = connect_to_postgresql()
        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT INTO logs (user_id, question, answer, is_answered, timestamp)
            VALUES (%s, %s, %s, %s, NOW())
            """,
            (username, question, answer, is_answered)
        )
        conn.commit()
    except Exception as e:
        print(f"L·ªói khi l∆∞u log: {e}")
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

# L·∫•y d·ªØ li·ªáu log t·ª´ database


def fetch_logs_data():
    conn = connect_to_postgresql()
    query = """
        SELECT question, is_answered, COUNT(*) as count
        FROM logs
        GROUP BY question, is_answered
        ORDER BY count DESC;
    """
    logs_df = pd.read_sql_query(query, conn)
    conn.close()
    return logs_df


def load_unanswered_questions():
    try:
        conn = connect_to_postgresql()
        cursor = conn.cursor()
        cursor.execute("SELECT question FROM unanswered_questions")
        unanswered_questions = cursor.fetchall()
        cursor.close()
        conn.close()
        print(f"D·ªØ li·ªáu t·∫£i v·ªÅ: {unanswered_questions}")  # Th√™m d√≤ng n√†y
        return [question[0] for question in unanswered_questions] if unanswered_questions else []
    except Exception as e:
        print(f"L·ªói khi t·∫£i c√¢u h·ªèi ch∆∞a tr·∫£ l·ªùi: {e}")
        return []


def show_statistics():
    try:
        conn = connect_to_postgresql()
        query = """
            SELECT question, COUNT(*) as count
            FROM user_questions
            GROUP BY question
            ORDER BY count DESC;
        """
        stats_df = pd.read_sql_query(query, conn)
        conn.close()

        st.subheader("üìä Th·ªëng k√™ c√¢u h·ªèi")

        fig = px.bar(stats_df, x='question', y='count',
                     title="Top nh·ªØng c√¢u h·ªèi")
        st.plotly_chart(fig)

    except Exception as e:
        st.error(f"L·ªói khi t·∫£i th·ªëng k√™: {e}")


def update_answer_for_unanswered(question, answer):
    try:
        conn = connect_to_postgresql()
        cursor = conn.cursor()

        cursor.execute("""
            INSERT INTO faq (question, answer)
            VALUES (%s, %s)
        """, (question, answer))

        cursor.execute("""
            DELETE FROM unanswered_questions 
            WHERE question = %s
        """, (question,))

        conn.commit()
        cursor.close()
        conn.close()
    except Exception as e:
        print(f"L·ªói khi c·∫≠p nh·∫≠t c√¢u tr·∫£ l·ªùi cho c√¢u h·ªèi ch∆∞a tr·∫£ l·ªùi: {e}")


def save_pdf_answer_to_db(question, answer):
    try:
        with connect_to_postgresql() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO faq (question, answer) VALUES (%s, %s)",
                (question, answer)
            )
            conn.commit()
            print("C√¢u h·ªèi v√† c√¢u tr·∫£ l·ªùi t·ª´ PDF ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o c∆° s·ªü d·ªØ li·ªáu.")
    except Exception as e:
        print(f"L·ªói khi l∆∞u c√¢u h·ªèi v√† c√¢u tr·∫£ l·ªùi t·ª´ PDF: {e}")


def log_unanswered_question(question):
    try:
        conn = connect_to_postgresql()
        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT INTO unanswered_questions (question, timestamp)
            VALUES (%s, NOW())
            """,
            (question,)
        )
        conn.commit()
        print("C√¢u h·ªèi ch∆∞a ƒë∆∞·ª£c tr·∫£ l·ªùi ƒë√£ ƒë∆∞·ª£c l∆∞u.")
    except Exception as e:
        print(f"L·ªói khi l∆∞u c√¢u h·ªèi ch∆∞a ƒë∆∞·ª£c tr·∫£ l·ªùi: {e}")
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()
